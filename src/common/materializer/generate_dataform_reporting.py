
import json
import logging
import os
import pathlib
import sys
import yaml
import re
from pathlib import Path
from jinja2 import Environment, FileSystemLoader

# Add parent directories to sys.path
sys.path.append(str(pathlib.Path(__file__).parent.parent)) 
sys.path.append(str(pathlib.Path(__file__).parent.parent.parent.parent)) # src/

from common.py_libs import configs
from common.py_libs import jinja as jinja_lib

# Constants
_REPORTING_SETTINGS_FILE = "src/SAP/SAP_REPORTING/reporting_settings_ecc.yaml" # Defaulting to ECC for now
_DATAFORM_REPORTING_DIR = "dataform/definitions/reporting"
_DATAFORM_INCLUDES_DIR = "dataform/includes"
_TEMPLATE_DIR = "src/SAP/SAP_REPORTING"

def generate_cortex_variables_js(config_dict, output_path):
    """Generates the content for cortex_variables.js based on config."""
    jinja_params = jinja_lib.initialize_jinja_from_config(config_dict)
    
    js_content = "// This file is generated by the migration script.\n"
    js_content += "// It contains constants from config.json to be used in Dataform SQLX files.\n\n"
    
    exports = []
    for key, value in jinja_params.items():
        if value is None:
            value = ""
        # Escape quotes if string
        if isinstance(value, str):
            js_content += f'const {key} = "{value}";\n'
        else:
            js_content += f'const {key} = {json.dumps(value)};\n'
        exports.append(key)
    
    js_content += "\nmodule.exports = {\n"
    js_content += ",\n".join(f"  {key}" for key in exports)
    js_content += "\n};\n"
    
    with open(output_path, "w") as f:
        f.write(js_content)
    logging.info(f"Generated {output_path}")
    return jinja_params.keys()

def create_dataform_context(keys, sql_flavour):
    """Creates a dict where value is the Dataform variable syntax."""
    context = {}
    for key in keys:
        context[key] = f"${{cortex_variables.{key}}}"
    
    # Override logic variables that need to be evaluated during generation, not runtime
    context["sql_flavour"] = sql_flavour
    context["sql_flavor"] = sql_flavour
    return context

def generate_sqlx(entry, env, context, output_dir):
    """Generates a single SQLX file."""
    sql_file = entry.get("sql_file")
    if not sql_file:
        return # Skip non-sql entries like k9_dawg for now

    obj_type = entry.get("type", "view")
    if obj_type == "script":
        obj_type = "operations" # Dataform equivalent
    
    description = entry.get("description", "")
    
    # Load and Render Template
    try:
        template = env.get_template(sql_file)
        rendered_sql = template.render(context)
    except Exception as e:
        logging.error(f"Failed to render {sql_file}: {e}")
        return

    except Exception as e:
        logging.error(f"Failed to render {sql_file}: {e}")
        return

    # Post-processing: Replace JS variable patterns with ref()
    # Pattern: ${cortex_variables.project}.${cortex_variables.dataset}.table
    # Note: project is often optional or source/target
    
    # We want to replace references to specific known datasets with ref()
    # Datasets that are part of the Dataform scope:
    # - dataset_cdc_processed
    # - dataset_cdc_processed_ecc
    # - dataset_cdc_processed_s4
    # - dataset_reporting_tgt
    # - dataset_raw_landing (because we declared them as sources)
    
    target_datasets_vars = [
        "dataset_cdc_processed", "dataset_cdc_processed_ecc", "dataset_cdc_processed_s4",
        "dataset_reporting_tgt", 
        "dataset_raw_landing", "dataset_raw_landing_ecc", "dataset_raw_landing_s4"
    ]
    
    # Regex to match: ${cortex_variables.PROJECT_VAR}.${cortex_variables.DATASET_VAR}.TABLE
    # We need to be careful with the project variable, it might be project_id_src or project_id_tgt
    
    pattern = r"\$\{cortex_variables\.[a-zA-Z0-9_]+\}\.\$\{cortex_variables\.(" + "|".join(target_datasets_vars) + r")\}\.([a-zA-Z0-9_]+)"
    
    def replacer(match):
        # match.group(1) is the dataset variable name (e.g. dataset_cdc_processed)
        # match.group(2) is the table name
        table_name = match.group(2)
        return f'${{ref("{table_name}")}}'
        
    try:
        rendered_sql = re.sub(pattern, replacer, rendered_sql)
    except Exception as e:
         logging.warning(f"Regex replacement failed for {sql_file}: {e}")

    # Construct SQLX
    
    # Construct SQLX
    name = Path(sql_file).stem
    filename = f"{output_dir}/{name}.sqlx"
    
    config_block = {
        "type": obj_type,
        "tags": ["reporting", "sap"],
        "description": description
    }
    
    # Handle table settings (simple mapping)
    if "table_setting" in entry:
        settings = entry["table_setting"]
        if "partition_details" in settings:
             config_block["bigquery"] = config_block.get("bigquery", {})
             config_block["bigquery"]["partitionBy"] = settings["partition_details"].get("column") # Simplified
        if "cluster_details" in settings:
             config_block["bigquery"] = config_block.get("bigquery", {})
             config_block["bigquery"]["clusterBy"] = settings["cluster_details"].get("columns")

    # Serialize config block
    config_str = "config " + json.dumps(config_block, indent=2)
    
    # Add JS dependency
    js_header = 'js { const cortex_variables = require("includes/cortex_variables.js"); }\n\n'
    
    content = js_header + config_str + "\n\n" + rendered_sql
    
    with open(filename, "w") as f:
        f.write(content)
    logging.info(f"Generated {filename}")

def main():
    logging.basicConfig(level=logging.INFO)
    
    config_path = os.environ.get("CONFIG_FILE", "config/config.json")
    try:
        config_dict = configs.load_config_file(config_path)
    except Exception as e:
        logging.error(f"Failed to load config: {e}")
        return

    orch_mode = config_dict.get("orchestrationMode", "dags").lower()
    if orch_mode != "dataform":
        logging.info(f"Skipping Dataform generation as orchestrationMode is '{orch_mode}'")
        return

    # 1. Generate JS Variables
    os.makedirs(_DATAFORM_INCLUDES_DIR, exist_ok=True)
    keys = generate_cortex_variables_js(config_dict, f"{_DATAFORM_INCLUDES_DIR}/cortex_variables.js")
    
    # 2. Setup Jinja Env
    env = Environment(loader=FileSystemLoader(_TEMPLATE_DIR))
    
    # 3. Create Generation Context
    # We assume 'ecc' flavour for this run, but this could be parameterized
    sql_flavour = config_dict["SAP"]["SQLFlavor"]
    context = create_dataform_context(keys, sql_flavour)
    
    # 4. Load Settings and Generate
    os.makedirs(_DATAFORM_REPORTING_DIR, exist_ok=True)
    
    with open(_REPORTING_SETTINGS_FILE) as f:
        settings = yaml.safe_load(f)
        
    all_objects = settings.get("bq_independent_objects", []) + settings.get("bq_dependent_objects", [])
    
    for obj in all_objects:
        generate_sqlx(obj, env, context, _DATAFORM_REPORTING_DIR)

if __name__ == "__main__":
    main()
